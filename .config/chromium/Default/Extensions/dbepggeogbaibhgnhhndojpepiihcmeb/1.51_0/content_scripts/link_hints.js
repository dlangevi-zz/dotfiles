// Generated by CoffeeScript 1.9.1
(function() {
  var COPY_LINK_URL, DOWNLOAD_LINK_URL, LinkHints, OPEN_INCOGNITO, OPEN_IN_CURRENT_TAB, OPEN_IN_NEW_BG_TAB, OPEN_IN_NEW_FG_TAB, OPEN_WITH_QUEUE, alphabetHints, filterHints, numberToHintString, root, spanWrap;

  OPEN_IN_CURRENT_TAB = {
    name: "curr-tab"
  };

  OPEN_IN_NEW_BG_TAB = {
    name: "bg-tab"
  };

  OPEN_IN_NEW_FG_TAB = {
    name: "fg-tab"
  };

  OPEN_WITH_QUEUE = {
    name: "queue"
  };

  COPY_LINK_URL = {
    name: "link"
  };

  OPEN_INCOGNITO = {
    name: "incognito"
  };

  DOWNLOAD_LINK_URL = {
    name: "download"
  };

  LinkHints = {
    hintMarkerContainingDiv: null,
    mode: void 0,
    linkActivator: void 0,
    delayMode: false,
    getMarkerMatcher: function() {
      if (settings.get("filterLinkHints")) {
        return filterHints;
      } else {
        return alphabetHints;
      }
    },
    isActive: false,
    onExit: null,
    init: function() {},
    activateModeToOpenInNewTab: function() {
      return this.activateMode(OPEN_IN_NEW_BG_TAB);
    },
    activateModeToOpenInNewForegroundTab: function() {
      return this.activateMode(OPEN_IN_NEW_FG_TAB);
    },
    activateModeToCopyLinkUrl: function() {
      return this.activateMode(COPY_LINK_URL);
    },
    activateModeWithQueue: function() {
      return this.activateMode(OPEN_WITH_QUEUE);
    },
    activateModeToOpenIncognito: function() {
      return this.activateMode(OPEN_INCOGNITO);
    },
    activateModeToDownloadLink: function() {
      return this.activateMode(DOWNLOAD_LINK_URL);
    },
    activateMode: function(mode) {
      var el, elements, hintMarkers, length;
      if (mode == null) {
        mode = OPEN_IN_CURRENT_TAB;
      }
      if (!document.documentElement) {
        return;
      }
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      elements = this.getVisibleClickableElements();
      if (mode === COPY_LINK_URL || mode === OPEN_INCOGNITO) {
        elements = (function() {
          var k, len, results;
          results = [];
          for (k = 0, len = elements.length; k < len; k++) {
            el = elements[k];
            if (el.element.href != null) {
              results.push(el);
            }
          }
          return results;
        })();
      }
      if (settings.get("filterLinkHints")) {
        length = function(el) {
          var ref, ref1;
          return (ref = (ref1 = el.element.innerHTML) != null ? ref1.length : void 0) != null ? ref : 0;
        };
        elements.sort(function(a, b) {
          return length(a) - length(b);
        });
      }
      hintMarkers = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = elements.length; k < len; k++) {
          el = elements[k];
          results.push(this.createMarkerFor(el));
        }
        return results;
      }).call(this);
      this.getMarkerMatcher().fillInMarkers(hintMarkers);
      this.hintMode = new Mode({
        name: "hint/" + mode.name,
        indicator: false,
        passInitialKeyupEvents: true,
        keydown: this.onKeyDownInMode.bind(this, hintMarkers),
        keypress: function() {
          return false;
        },
        keyup: function() {
          return false;
        }
      });
      this.setOpenLinkMode(mode);
      return this.hintMarkerContainingDiv = DomUtils.addElementList(hintMarkers, {
        id: "vimiumHintMarkerContainer",
        className: "vimiumReset"
      });
    },
    setOpenLinkMode: function(mode1) {
      this.mode = mode1;
      if (this.mode === OPEN_IN_NEW_BG_TAB || this.mode === OPEN_IN_NEW_FG_TAB || this.mode === OPEN_WITH_QUEUE) {
        if (this.mode === OPEN_IN_NEW_BG_TAB) {
          this.hintMode.setIndicator("Open link in new tab");
        } else if (this.mode === OPEN_IN_NEW_FG_TAB) {
          this.hintMode.setIndicator("Open link in new tab and switch to it");
        } else {
          this.hintMode.setIndicator("Open multiple links in a new tab");
        }
        return this.linkActivator = function(link) {
          return DomUtils.simulateClick(link, {
            shiftKey: this.mode === OPEN_IN_NEW_FG_TAB,
            metaKey: KeyboardUtils.platform === "Mac",
            ctrlKey: KeyboardUtils.platform !== "Mac",
            altKey: false
          });
        };
      } else if (this.mode === COPY_LINK_URL) {
        this.hintMode.setIndicator("Copy link URL to Clipboard");
        return this.linkActivator = (function(_this) {
          return function(link) {
            var url;
            if (link.href != null) {
              chrome.runtime.sendMessage({
                handler: "copyToClipboard",
                data: link.href
              });
              url = link.href;
              if (28 < url.length) {
                url = url.slice(0, 26) + "....";
              }
              return _this.onExit = function() {
                return HUD.showForDuration("Yanked " + url, 2000);
              };
            } else {
              return _this.onExit = function() {
                return HUD.showForDuration("No link to yank.", 2000);
              };
            }
          };
        })(this);
      } else if (this.mode === OPEN_INCOGNITO) {
        this.hintMode.setIndicator("Open link in incognito window");
        return this.linkActivator = function(link) {
          return chrome.runtime.sendMessage({
            handler: 'openUrlInIncognito',
            url: link.href
          });
        };
      } else if (this.mode === DOWNLOAD_LINK_URL) {
        this.hintMode.setIndicator("Download link URL");
        return this.linkActivator = function(link) {
          return DomUtils.simulateClick(link, {
            altKey: true,
            ctrlKey: false,
            metaKey: false
          });
        };
      } else {
        this.hintMode.setIndicator("Open link in current tab");
        return this.linkActivator = function(link) {
          return DomUtils.simulateClick.bind(DomUtils, link)();
        };
      }
    },
    createMarkerFor: function(link) {
      var clientRect, marker;
      marker = document.createElement("div");
      marker.className = "vimiumReset internalVimiumHintMarker vimiumHintMarker";
      marker.clickableItem = link.element;
      clientRect = link.rect;
      marker.style.left = clientRect.left + window.scrollX + "px";
      marker.style.top = clientRect.top + window.scrollY + "px";
      marker.rect = link.rect;
      return marker;
    },
    getVisibleClickable: function(element) {
      var areas, areasAndRects, clientRect, imgClientRects, isClickable, jsactionRule, jsactionRules, k, len, map, mapName, onlyHasTabIndex, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, ruleSplit, tabIndex, tabIndexValue, tagName, visibleElements;
      tagName = element.tagName.toLowerCase();
      isClickable = false;
      onlyHasTabIndex = false;
      visibleElements = [];
      if (tagName === "img") {
        mapName = element.getAttribute("usemap");
        if (mapName) {
          imgClientRects = element.getClientRects();
          mapName = mapName.replace(/^#/, "").replace("\"", "\\\"");
          map = document.querySelector("map[name=\"" + mapName + "\"]");
          if (map && imgClientRects.length > 0) {
            areas = map.getElementsByTagName("area");
            areasAndRects = DomUtils.getClientRectsForAreas(imgClientRects[0], areas);
            visibleElements.push.apply(visibleElements, areasAndRects);
          }
        }
      }
      if (((ref = (ref1 = element.getAttribute("aria-hidden")) != null ? ref1.toLowerCase() : void 0) === "" || ref === "true") || ((ref2 = (ref3 = element.getAttribute("aria-disabled")) != null ? ref3.toLowerCase() : void 0) === "" || ref2 === "true")) {
        return [];
      }
      if (element.hasAttribute("onclick") || ((ref4 = (ref5 = element.getAttribute("role")) != null ? ref5.toLowerCase() : void 0) === "button" || ref4 === "link") || ((ref6 = element.getAttribute("class")) != null ? ref6.toLowerCase().indexOf("button") : void 0) >= 0 || ((ref7 = (ref8 = element.getAttribute("contentEditable")) != null ? ref8.toLowerCase() : void 0) === "" || ref7 === "contentEditable" || ref7 === "true")) {
        isClickable = true;
      }
      if (element.hasAttribute("jsaction")) {
        jsactionRules = element.getAttribute("jsaction").split(";");
        for (k = 0, len = jsactionRules.length; k < len; k++) {
          jsactionRule = jsactionRules[k];
          ruleSplit = jsactionRule.split(":");
          isClickable || (isClickable = ruleSplit[0] === "click" || (ruleSplit.length === 1 && ruleSplit[0] !== "none"));
        }
      }
      switch (tagName) {
        case "a":
          isClickable = true;
          break;
        case "textarea":
          isClickable || (isClickable = !element.disabled && !element.readOnly);
          break;
        case "input":
          isClickable || (isClickable = !(((ref9 = element.getAttribute("type")) != null ? ref9.toLowerCase() : void 0) === "hidden" || element.disabled || (element.readOnly && DomUtils.isSelectable(element))));
          break;
        case "button":
        case "select":
          isClickable || (isClickable = !element.disabled);
      }
      tabIndexValue = element.getAttribute("tabindex");
      tabIndex = tabIndexValue === "" ? 0 : parseInt(tabIndexValue);
      if (!(isClickable || isNaN(tabIndex) || tabIndex < 0)) {
        isClickable = onlyHasTabIndex = true;
      }
      if (isClickable) {
        clientRect = DomUtils.getVisibleClientRect(element, true);
        if (clientRect !== null) {
          visibleElements.push({
            element: element,
            rect: clientRect,
            secondClassCitizen: onlyHasTabIndex
          });
        }
      }
      return visibleElements;
    },
    getVisibleClickableElements: function() {
      var element, elements, k, l, len, len1, negativeRect, nonOverlappingElements, rects, ref, visibleElement, visibleElements;
      elements = document.documentElement.getElementsByTagName("*");
      visibleElements = [];
      for (k = 0, len = elements.length; k < len; k++) {
        element = elements[k];
        visibleElement = this.getVisibleClickable(element);
        visibleElements.push.apply(visibleElements, visibleElement);
      }
      nonOverlappingElements = [];
      visibleElements = visibleElements.reverse();
      while (visibleElement = visibleElements.pop()) {
        rects = [visibleElement.rect];
        for (l = 0, len1 = visibleElements.length; l < len1; l++) {
          negativeRect = visibleElements[l].rect;
          rects = (ref = []).concat.apply(ref, rects.map(function(rect) {
            return Rect.subtract(rect, negativeRect);
          }));
        }
        if (rects.length > 0) {
          nonOverlappingElements.push({
            element: visibleElement.element,
            rect: rects[0]
          });
        } else {
          if (!visibleElement.secondClassCitizen) {
            nonOverlappingElements.push(visibleElement);
          }
        }
      }
      return nonOverlappingElements;
    },
    onKeyDownInMode: function(hintMarkers, event) {
      var delay, k, keyCode, keyResult, l, len, len1, linksMatched, marker, matched, previousMode, ref;
      if (this.delayMode || event.repeat) {
        return;
      }
      if ((event.keyCode === keyCodes.shiftKey || event.keyCode === keyCodes.ctrlKey) && (this.mode === OPEN_IN_CURRENT_TAB || this.mode === OPEN_WITH_QUEUE || this.mode === OPEN_IN_NEW_BG_TAB || this.mode === OPEN_IN_NEW_FG_TAB)) {
        previousMode = this.mode;
        keyCode = event.keyCode;
        switch (keyCode) {
          case keyCodes.shiftKey:
            this.setOpenLinkMode(this.mode === OPEN_IN_CURRENT_TAB ? OPEN_IN_NEW_BG_TAB : OPEN_IN_CURRENT_TAB);
            break;
          case keyCodes.ctrlKey:
            this.setOpenLinkMode(this.mode === OPEN_IN_NEW_FG_TAB ? OPEN_IN_NEW_BG_TAB : OPEN_IN_NEW_FG_TAB);
        }
        handlerStack.push({
          keyup: (function(_this) {
            return function(event) {
              if (event.keyCode === keyCode) {
                handlerStack.remove();
                if (_this.isActive) {
                  _this.setOpenLinkMode(previousMode);
                }
              }
              return true;
            };
          })(this)
        });
      }
      if (KeyboardUtils.isEscape(event)) {
        DomUtils.suppressKeyupAfterEscape(handlerStack);
        this.deactivateMode();
      } else if (event.keyCode !== keyCodes.shiftKey && event.keyCode !== keyCodes.ctrlKey) {
        keyResult = this.getMarkerMatcher().matchHintsByKey(hintMarkers, event);
        linksMatched = keyResult.linksMatched;
        delay = (ref = keyResult.delay) != null ? ref : 0;
        if (linksMatched.length === 0) {
          this.deactivateMode();
        } else if (linksMatched.length === 1) {
          this.activateLink(linksMatched[0], delay);
        } else {
          for (k = 0, len = hintMarkers.length; k < len; k++) {
            marker = hintMarkers[k];
            this.hideMarker(marker);
          }
          for (l = 0, len1 = linksMatched.length; l < len1; l++) {
            matched = linksMatched[l];
            this.showMarker(matched, this.getMarkerMatcher().hintKeystrokeQueue.length);
          }
        }
      }
      return false;
    },
    activateLink: function(matchedLink, delay) {
      var clickEl, ref;
      this.delayMode = true;
      clickEl = matchedLink.clickableItem;
      if (DomUtils.isSelectable(clickEl)) {
        DomUtils.simulateSelect(clickEl);
        return this.deactivateMode(delay, function() {
          return LinkHints.delayMode = false;
        });
      } else {
        if (clickEl.nodeName.toLowerCase() === "input" && ((ref = clickEl.type) !== "button" && ref !== "submit")) {
          clickEl.focus();
        }
        DomUtils.flashRect(matchedLink.rect);
        this.linkActivator(clickEl);
        if (this.mode === OPEN_WITH_QUEUE) {
          return this.deactivateMode(delay, function() {
            LinkHints.delayMode = false;
            return LinkHints.activateModeWithQueue();
          });
        } else {
          return this.deactivateMode(delay, function() {
            return LinkHints.delayMode = false;
          });
        }
      }
    },
    showMarker: function(linkMarker, matchingCharCount) {
      var j, k, ref, results;
      linkMarker.style.display = "";
      results = [];
      for (j = k = 0, ref = linkMarker.childNodes.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
        if (j < matchingCharCount) {
          results.push(linkMarker.childNodes[j].classList.add("matchingCharacter"));
        } else {
          results.push(linkMarker.childNodes[j].classList.remove("matchingCharacter"));
        }
      }
      return results;
    },
    hideMarker: function(linkMarker) {
      return linkMarker.style.display = "none";
    },
    deactivateMode: function(delay, callback) {
      var deactivate;
      deactivate = (function(_this) {
        return function() {
          if ((LinkHints.getMarkerMatcher().deactivate)) {
            LinkHints.getMarkerMatcher().deactivate();
          }
          if (LinkHints.hintMarkerContainingDiv) {
            DomUtils.removeElement(LinkHints.hintMarkerContainingDiv);
          }
          LinkHints.hintMarkerContainingDiv = null;
          _this.hintMode.exit();
          if (typeof _this.onExit === "function") {
            _this.onExit();
          }
          _this.onExit = null;
          return _this.isActive = false;
        };
      })(this);
      if (!delay) {
        deactivate();
        if (callback) {
          return callback();
        }
      } else {
        return setTimeout(function() {
          deactivate();
          if (callback) {
            return callback();
          }
        }, delay);
      }
    }
  };

  alphabetHints = {
    hintKeystrokeQueue: [],
    logXOfBase: function(x, base) {
      return Math.log(x) / Math.log(base);
    },
    fillInMarkers: function(hintMarkers) {
      var hintStrings, idx, k, len, marker;
      hintStrings = this.hintStrings(hintMarkers.length);
      for (idx = k = 0, len = hintMarkers.length; k < len; idx = ++k) {
        marker = hintMarkers[idx];
        marker.hintString = hintStrings[idx];
        marker.innerHTML = spanWrap(marker.hintString.toUpperCase());
      }
      return hintMarkers;
    },
    hintStrings: function(linkCount) {
      var digitsNeeded, hintStrings, i, k, l, linkHintCharacters, longHintCount, ref, ref1, ref2, shortHintCount, start;
      linkHintCharacters = settings.get("linkHintCharacters");
      digitsNeeded = Math.ceil(this.logXOfBase(linkCount, linkHintCharacters.length));
      shortHintCount = Math.floor((Math.pow(linkHintCharacters.length, digitsNeeded) - linkCount) / linkHintCharacters.length);
      longHintCount = linkCount - shortHintCount;
      hintStrings = [];
      if (digitsNeeded > 1) {
        for (i = k = 0, ref = shortHintCount; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          hintStrings.push(numberToHintString(i, linkHintCharacters, digitsNeeded - 1));
        }
      }
      start = shortHintCount * linkHintCharacters.length;
      for (i = l = ref1 = start, ref2 = start + longHintCount; ref1 <= ref2 ? l < ref2 : l > ref2; i = ref1 <= ref2 ? ++l : --l) {
        hintStrings.push(numberToHintString(i, linkHintCharacters, digitsNeeded));
      }
      return this.shuffleHints(hintStrings, linkHintCharacters.length);
    },
    shuffleHints: function(hints, characterSetLength) {
      var bucket, buckets, hint, i, k, l, len, len1, result;
      buckets = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = characterSetLength; k < ref; i = k += 1) {
          results.push([]);
        }
        return results;
      })();
      for (i = k = 0, len = hints.length; k < len; i = ++k) {
        hint = hints[i];
        buckets[i % buckets.length].push(hint);
      }
      result = [];
      for (l = 0, len1 = buckets.length; l < len1; l++) {
        bucket = buckets[l];
        result = result.concat(bucket);
      }
      return result;
    },
    matchHintsByKey: function(hintMarkers, event) {
      var keyChar, linksMatched, matchString;
      keyChar = KeyboardUtils.getKeyChar(event).toLowerCase();
      if (event.keyCode === keyCodes.backspace || event.keyCode === keyCodes.deleteKey) {
        if (!this.hintKeystrokeQueue.pop()) {
          return {
            linksMatched: []
          };
        }
      } else if (keyChar) {
        this.hintKeystrokeQueue.push(keyChar);
      }
      matchString = this.hintKeystrokeQueue.join("");
      linksMatched = hintMarkers.filter(function(linkMarker) {
        return linkMarker.hintString.indexOf(matchString) === 0;
      });
      return {
        linksMatched: linksMatched
      };
    },
    deactivate: function() {
      return this.hintKeystrokeQueue = [];
    }
  };

  filterHints = {
    hintKeystrokeQueue: [],
    linkTextKeystrokeQueue: [],
    labelMap: {},
    generateLabelMap: function() {
      var forElement, k, label, labelText, labels, len, results;
      labels = document.querySelectorAll("label");
      results = [];
      for (k = 0, len = labels.length; k < len; k++) {
        label = labels[k];
        forElement = label.getAttribute("for");
        if (forElement) {
          labelText = label.textContent.trim();
          if (labelText[labelText.length - 1] === ":") {
            labelText = labelText.substr(0, labelText.length - 1);
          }
          results.push(this.labelMap[forElement] = labelText);
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    generateHintString: function(linkHintNumber) {
      return (numberToHintString(linkHintNumber + 1, settings.get("linkHintNumbers"))).toUpperCase();
    },
    generateLinkText: function(element) {
      var linkText, nodeName, showLinkText;
      linkText = "";
      showLinkText = false;
      nodeName = element.nodeName.toLowerCase();
      if (nodeName === "input") {
        if (this.labelMap[element.id]) {
          linkText = this.labelMap[element.id];
          showLinkText = true;
        } else if (element.type !== "password") {
          linkText = element.value;
          if (!linkText && 'placeholder' in element) {
            linkText = element.placeholder;
          }
        }
      } else if (nodeName === "a" && !element.textContent.trim() && element.firstElementChild && element.firstElementChild.nodeName.toLowerCase() === "img") {
        linkText = element.firstElementChild.alt || element.firstElementChild.title;
        if (linkText) {
          showLinkText = true;
        }
      } else {
        linkText = DomUtils.textContent.get(element);
      }
      return {
        text: linkText,
        show: showLinkText
      };
    },
    renderMarker: function(marker) {
      return marker.innerHTML = spanWrap(marker.hintString + (marker.showLinkText ? ": " + marker.linkText : ""));
    },
    fillInMarkers: function(hintMarkers) {
      var idx, k, len, linkTextObject, marker;
      this.generateLabelMap();
      DomUtils.textContent.reset();
      for (idx = k = 0, len = hintMarkers.length; k < len; idx = ++k) {
        marker = hintMarkers[idx];
        marker.hintString = this.generateHintString(idx);
        linkTextObject = this.generateLinkText(marker.clickableItem);
        marker.linkText = linkTextObject.text;
        marker.showLinkText = linkTextObject.show;
        this.renderMarker(marker);
      }
      return hintMarkers;
    },
    matchHintsByKey: function(hintMarkers, event) {
      var delay, k, keyChar, len, linksMatched, marker, matchString, userIsTypingLinkText;
      keyChar = KeyboardUtils.getKeyChar(event);
      delay = 0;
      userIsTypingLinkText = false;
      if (event.keyCode === keyCodes.enter) {
        for (k = 0, len = hintMarkers.length; k < len; k++) {
          marker = hintMarkers[k];
          if (marker.style.display !== "none") {
            return {
              linksMatched: [marker]
            };
          }
        }
      } else if (event.keyCode === keyCodes.backspace || event.keyCode === keyCodes.deleteKey) {
        if (!this.hintKeystrokeQueue.pop() && !this.linkTextKeystrokeQueue.pop()) {
          return {
            linksMatched: []
          };
        }
      } else if (keyChar) {
        if (settings.get("linkHintNumbers").indexOf(keyChar) >= 0) {
          this.hintKeystrokeQueue.push(keyChar);
        } else {
          this.hintKeystrokeQueue = [];
          this.linkTextKeystrokeQueue.push(keyChar);
          userIsTypingLinkText = true;
        }
      }
      linksMatched = this.filterLinkHints(hintMarkers);
      matchString = this.hintKeystrokeQueue.join("");
      linksMatched = linksMatched.filter(function(linkMarker) {
        return !linkMarker.filtered && linkMarker.hintString.indexOf(matchString) === 0;
      });
      if (linksMatched.length === 1 && userIsTypingLinkText) {
        delay = 200;
      }
      return {
        linksMatched: linksMatched,
        delay: delay
      };
    },
    filterLinkHints: function(hintMarkers) {
      var k, len, linkMarker, linkSearchString, linksMatched, matchedLink, oldHintString;
      linksMatched = [];
      linkSearchString = this.linkTextKeystrokeQueue.join("");
      for (k = 0, len = hintMarkers.length; k < len; k++) {
        linkMarker = hintMarkers[k];
        matchedLink = linkMarker.linkText.toLowerCase().indexOf(linkSearchString.toLowerCase()) >= 0;
        if (!matchedLink) {
          linkMarker.filtered = true;
        } else {
          linkMarker.filtered = false;
          oldHintString = linkMarker.hintString;
          linkMarker.hintString = this.generateHintString(linksMatched.length);
          if (linkMarker.hintString !== oldHintString) {
            this.renderMarker(linkMarker);
          }
          linksMatched.push(linkMarker);
        }
      }
      return linksMatched;
    },
    deactivate: function(delay, callback) {
      this.hintKeystrokeQueue = [];
      this.linkTextKeystrokeQueue = [];
      return this.labelMap = {};
    }
  };

  spanWrap = function(hintString) {
    var char, innerHTML, k, len;
    innerHTML = [];
    for (k = 0, len = hintString.length; k < len; k++) {
      char = hintString[k];
      innerHTML.push("<span class='vimiumReset'>" + char + "</span>");
    }
    return innerHTML.join("");
  };

  numberToHintString = function(number, characterSet, numHintDigits) {
    var base, hintString, hintStringLength, i, k, ref, remainder;
    if (numHintDigits == null) {
      numHintDigits = 0;
    }
    base = characterSet.length;
    hintString = [];
    remainder = 0;
    while (true) {
      remainder = number % base;
      hintString.unshift(characterSet[remainder]);
      number -= remainder;
      number /= Math.floor(base);
      if (!(number > 0)) {
        break;
      }
    }
    hintStringLength = hintString.length;
    for (i = k = 0, ref = numHintDigits - hintStringLength; k < ref; i = k += 1) {
      hintString.unshift(characterSet[0]);
    }
    return hintString.join("");
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.LinkHints = LinkHints;

}).call(this);
